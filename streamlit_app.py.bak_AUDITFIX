import matplotlib.pyplot as plt
from datetime import date
from pathlib import Path

import pandas as pd
import streamlit as st
# Query params (Streamlit >= 1.30)
params = st.query_params
_u = params.get("user")
_t = params.get("reset_token")
if _u and _t:
    if isinstance(_u, list): _u = _u[0]
    if isinstance(_t, list): _t = _t[0]
    st.session_state["_pending_user"] = _u
    st.session_state["_pending_token"] = _t
import os, time, time

from app.email_utils import send_email
from app.datastore import set_password, set_account_email, set_recovery_email, get_emails_for_user, set_profile, get_password_reset, create_password_reset, clear_password_reset

from app.datastore import (
    ensure_base_dirs, register_user, authenticate, load_user, save_user,
)
from app.exercises import (
    list_all_exercises, add_custom_exercise, remove_custom_exercise, rename_custom_exercise,
    save_exercise_meta, get_exercise_meta, GRUPOS, store_exercise_image,
)
from app.training import (
    add_training_set, list_training, last_values_for_exercise,
)
from app.health import (
    add_weight, list_weights,
)
from app.routines import (
    list_routines, add_routine, delete_routine, rename_routine, apply_routine
)

st.set_page_config(page_title="Gym App Web", page_icon="üèãÔ∏è", layout="wide")
ensure_base_dirs()

def require_auth():
    if "user" not in st.session_state or not st.session_state["user"]:
        st.warning("Inicia sesi√≥n para continuar.")
        st.stop()

def logout():
    st.session_state.clear()
    st.rerun()

with st.sidebar:
    if "user" in st.session_state and st.session_state["user"]:
        st.success(f"Conectado como **{st.session_state['user']}**")
        if st.button("Cerrar sesi√≥n", use_container_width=True):
            logout()
    st.markdown("---")
    page = st.radio(
        "Secciones",
        [
            "üîê Login / Registro",
            "üè† Inicio",
            "üèãÔ∏è A√±adir entrenamiento",
            "üìö Gestor de ejercicios",
            "üìà Tabla de entrenamientos",
            "ü©∫ Salud (Peso)",
            "üìò Rutinas",
            "üë§ Perfil",
        ],
        index=0 if "user" not in st.session_state else 1,
    )

if page == "üîê Login / Registro":
    st.title("Acceso")

    col1, col2 = st.columns(2)

    with col1:
        st.subheader("Iniciar sesi√≥n")
        u = st.text_input("Usuario")
        p = st.text_input("Contrase√±a", type="password")

        # Reseteo por token desde URL (?user=&reset_token=)
        if st.session_state.get("_pending_user") and st.session_state.get("_pending_token"):
            u_tok = st.session_state.pop("_pending_user")
            tk = st.session_state.pop("_pending_token")
            data_tok = get_password_reset(u_tok)
            if data_tok and data_tok.get("token") == tk and data_tok.get("expires_at", 0) >= int(time.time()):
                st.success(f"Token v√°lido para **{u_tok}**. Establece nueva contrase√±a:")
                with st.form("reset_from_link"):
                    p1 = st.text_input("Nueva contrase√±a", type="password")
                    p2 = st.text_input("Repite la nueva contrase√±a", type="password")
                    done = st.form_submit_button("Guardar")
                if done:
                    if p1 and p1 == p2:
                        set_password(u_tok, p1)
                        clear_password_reset(u_tok)
                        st.success("Contrase√±a actualizada. Ya puedes iniciar sesi√≥n.")
                    else:
                        st.error("Las contrase√±as no coinciden.")
            else:
                st.error("El enlace/c√≥digo de recuperaci√≥n no es v√°lido o ha caducado.")

        with st.expander("Olvid√© mi contrase√±a"):
            rec_id = st.text_input("Tu usuario o email de recuperaci√≥n", key="forgot_id")
            if st.button("Enviar enlace de recuperaci√≥n", key="forgot_btn"):
                target_user = None
                if rec_id:
                    try:
                        _ = load_user(rec_id)  # como usuario
                        target_user = rec_id
                    except Exception:
                        pass
                if not target_user:
                    import glob, json
                    from pathlib import Path as _P
                    for pth in glob.glob(str((_P(".")/"usuarios_data"/"*.json").resolve())):
                        try:
                            d = json.load(open(pth, "r", encoding="utf-8"))
                            if d.get("recovery_email") == rec_id or d.get("email") == rec_id:
                                target_user = _P(pth).stem
                                break
                        except Exception:
                            pass
                if not target_user:
                    st.info("Si existe, te llegar√° un correo con instrucciones.")
                else:
                    token = __import__("secrets").token_urlsafe(24)
                    create_password_reset(target_user, token, ttl_seconds=3600)
                    base_url = os.getenv("APP_BASE_URL", "")
                    link = f"{base_url}?user={target_user}&reset_token={token}" if base_url else f"(Configura APP_BASE_URL) token: {token}"
                    acc, rec = get_emails_for_user(target_user)
                    to_email = rec or acc
                    ok, msg = send_email(to_email, "Recuperaci√≥n de contrase√±a",
                        f"<p>Hola {target_user},</p><p>Enlace para restablecer (1h): <a href='{link}'>{link}</a></p><p>C√≥digo: <b>{token}</b></p>",
                        text=f"Enlace: {link}\nC√≥digo: {token}")
                    if ok:
                        st.info("Si existe, te llegar√° un correo con instrucciones.")
                    else:
                        st.warning("No se pudo enviar email. Usa este c√≥digo en la app: " + token)

        if st.button("Iniciar sesi√≥n"):
            if not u or not p:
                st.warning("Completa usuario y contrase√±a.")
            else:
                if authenticate(u, p):
                    st.session_state["user"] = u
                    st.success("Sesi√≥n iniciada.")
                    st.rerun()
                else:
                    st.error("Usuario o contrase√±a incorrectos.")

    with col2:
                objetivo = st.selectbox("Objetivo", ["fuerza","hipertrofia","resistencia","mixto"], index=0)

                # --- Material (con presets) ---
                material_preset = st.radio(
                    "Material (preset)",
                    ["Todo", "Gomas", "Personalizado"],
                    index=0,
                    horizontal=True
                )
                material_personalizado = []
                if material_preset == "Personalizado":
                    material_personalizado = st.multiselect(
                        "Material disponible (personalizado)",
                        ["barra","mancuernas","poleas","m√°quinas","banco","rack",
                         "prensa","dominadas","anillas","gomas","ninguno"]
                    )
                # Normalizamos a lista enviable
                material = (
                    ["todo"] if material_preset == "Todo"
                    else (["gomas"] if material_preset == "Gomas" else material_personalizado)
                )

                limitaciones = st.text_input("Lesiones/limitaciones (opcional)", placeholder="Hombro, rodilla, ...")
                superseries_ok = st.checkbox("Permitir superseries", value=True)
                deload_semana_pref = st.number_input("Deload preferido (semana)", min_value=0, max_value=12, value=5, help="0 = sin preferencia")
                unidades = st.selectbox("Unidades", ["kg","lb"], index=0)
                idioma = st.selectbox("Idioma", ["es","en"], index=0)

    st.markdown("#### Experiencia y PR recientes")
    c1, c2, c3 = st.columns(3)
    with c1:
        exp_banca = st.text_input("Banca (experiencia)", value="2 a√±os")
        pr_banca = st.number_input("Banca 1x3 (kg)", value=80, step=2)
    with c2:
        exp_sentadilla = st.text_input("Sentadilla (experiencia)", value="1 a√±o")
        pr_senta = st.number_input("Sentadilla 1x3 (kg)", value=110, step=2)
    with c3:
        exp_muerto = st.text_input("Peso muerto (experiencia)", value="1 a√±o")
        pr_muerto = st.number_input("Muerto 1x3 (kg)", value=130, step=2)

    enfasis = st.multiselect("√ânfasis accesorios", ["espalda alta","gluteo","triceps","biceps","core"], default=["espalda alta","core"])
    evitar_txt = st.text_input("Evitar movimientos (separar por comas)", value="press militar de pie pesado")
    calentamiento = st.selectbox("Calentamiento", ["breve","medio","largo"], index=0)

    # --- Preferencias extra ---
    agrupacion = st.selectbox("Estructura de grupos por d√≠a", ["Varios grupos principales por d√≠a", "Un solo grupo principal por d√≠a"], index=0)
    comentarios = st.text_area("Comentarios y observaciones (opcional)", placeholder="Ej.: solo un d√≠a pierna/gl√∫teo ‚Ä¢ a√±adir 1 d√≠a de cardio + core ‚Ä¢ evitar press militar...", height=120)
    submitted = st.form_submit_button("Generar rutina")

        # ---------- Funci√≥n de render tipo PDF ----------
def render_rutina_tabular(rutina: dict):
    st.subheader("Plan (vista tipo PDF)")
    dias = rutina.get("dias", [])
    if not dias:
        st.info("No hay d√≠as en la rutina.")
        return
    tabs = st.tabs([d.get("nombre", f"D√≠a {i+1}") for i, d in enumerate(dias)])
    for i, dia in enumerate(dias):
        with tabs[i]:
            rows = [{
                "Ejercicio": ej.get("nombre",""),
                "Series": ej.get("series",""),
                "Reps": ej.get("reps",""),
                "Descanso": ej.get("descanso",""),
                "Intensidad": ej.get("intensidad","") or ""
            } for ej in dia.get("ejercicios", [])]
            import pandas as _pd
            st.table(_pd.DataFrame(rows, columns=["Ejercicio","Series","Reps","Descanso","Intensidad"]))
            if dia.get("notas"):
                st.caption("Notas: " + dia["notas"])
    prog = rutina.get("progresion", {})
    st.markdown("### Progresi√≥n")
    st.write(
        f"- **Principales:** {prog.get('principales','')}\n"
        f"- **Accesorios:** {prog.get('accesorios','')}\n"
        f"- **Deload (semana):** {prog.get('deload_semana','')}"
    )

    # ---------- Llamada a IA / Fallback ----------
        if submitted:
            datos_usuario = {
                "nivel": nivel,
                "dias": int(dias),
                "duracion": int(duracion),
                "objetivo": objetivo,
                "material": material,
        "agrupacion": agrupacion,
        "comentarios": comentarios.strip(),
                "lesiones": limitaciones.strip(),
                "disponibilidad": disponibilidad,
                "progresion_preferida": progresion_pref,
                "volumen_tolerancia": volumen_tol,
                "semanas_ciclo": int(semanas_ciclo),
                "superseries_ok": bool(superseries_ok),
                "deload_preferido_semana": int(deload_semana_pref),
                "unidades": unidades,
                "idioma": idioma,
                "experiencia": {"banca": exp_banca, "sentadilla": exp_sentadilla, "peso_muerto": exp_muerto},
                "pr_recientes": {"banca_1x3": pr_banca, "sentadilla_1x3": pr_senta, "muerto_1x3": pr_muerto, "unidad": unidades},
                "enfasis_accesorios": enfasis,
                "evitar": [s.strip() for s in evitar_txt.split(",") if s.strip()],
                "calentamiento": calentamiento
            }
            api_key_ok = bool(os.getenv("OPENAI_API_KEY"))
            if api_key_ok:
                with st.spinner("Generando con ChatGPT..."):
                    result = call_gpt(datos_usuario)
                    if result.get("ok"):
                        st.session_state["rutina_ia"] = result["data"]
                    else:
                        st.session_state["rutina_ia"] = generate_fallback(datos_usuario)
                        st.session_state["ia_error"] = result.get("error","Error desconocido")
                        st.warning("Se us√≥ el plan de respaldo. Configura OPENAI_API_KEY para usar ChatGPT.")
            else:
                st.session_state["rutina_ia"] = generate_fallback(datos_usuario)
                st.warning("Se us√≥ el plan de respaldo. Configura OPENAI_API_KEY para usar ChatGPT.")
            st.session_state["rutina_meta"] = {"nivel": nivel, "objetivo": objetivo, "duracion": int(duracion)}

        # ---------- Mostrar desde sesi√≥n ----------
        rutina_view = st.session_state.get("rutina_ia")
        if rutina_view:
            render_rutina_tabular(rutina_view)

            pdf_bytes = rutina_a_pdf_bytes(rutina_view)
            st.download_button("üìÑ Descargar PDF", data=pdf_bytes, file_name="rutina.pdf", mime="application/pdf")
            st.download_button("üì• Descargar JSON", data=json.dumps(rutina_view, ensure_ascii=False, indent=2),
                               file_name="rutina.json", mime="application/json")

            st.markdown("---")
            st.subheader("üìÖ Nombra, asigna d√≠as y programa semanas")

            dias_semana = ["Lunes","Martes","Mi√©rcoles","Jueves","Viernes","S√°bado","Domingo"]
            with st.form("planificacion_form", clear_on_submit=False):
                schedule = []
                for i, dia in enumerate(rutina_view.get("dias", [])):
                    st.write(f"**{i+1}. {dia.get('nombre','D√≠a')}**")
                    c1, c2 = st.columns(2)
                    weekday = c1.selectbox("D√≠a de la semana", dias_semana, key=f"weekday_ai_{i}")
                    custom_name = c2.text_input("Nombre de la rutina", value=dia.get("nombre","D√≠a"), key=f"dname_ai_{i}")
                    schedule.append({
                        "day_index": i,
                        "weekday": dias_semana.index(weekday),
                        "name": custom_name
                    })
                cA, cB, cC = st.columns(3)
                start_date = cA.date_input("Inicio", value=_dt.date.today(), key="plan_start")
                weeks = cB.number_input("Semanas", min_value=1, max_value=52, value=4, step=1, key="plan_weeks")
                guardar = cC.form_submit_button("üíæ Guardar y programar")

            if guardar:
                existing = [r["name"] for r in list_routines(user)]
                def _ensure_unique(name, existing_names):
                    base, n, cand = name, 1, name
                    while cand in existing_names:
                        n += 1
                        cand = f"{base} ({n})"
                    existing_names.append(cand)
                    return cand

                created = []
                for s in schedule:
                    d = rutina_view["dias"][s["day_index"]]
                    rname = _ensure_unique(s["name"].strip() or d.get("nombre","D√≠a"), existing)
                    items = []
                    for ej in d.get("ejercicios", []):
                        reps = ej.get("reps","10")
                        try:
                            reps_val = int(str(reps).replace("‚Äì","-").split("-")[-1].strip())
                        except:
                            reps_val = 10
                        items.append({"exercise": ej.get("nombre",""), "sets": int(ej.get("series",3)), "reps": reps_val, "weight": 0.0})
                    add_routine(user, rname, items)
                    created.append((s["weekday"], rname))

                try:
                    base_mon = start_date - _dt.timedelta(days=start_date.weekday())
                    for w in range(int(weeks)):
                        for wd, rname in created:
                            d = base_mon + _dt.timedelta(weeks=w, days=int(wd))
                            _set_plan(user, d.isoformat(), rname)
                    st.success("Rutinas guardadas y programadas ‚úÖ")
                except NameError:
                    st.warning("No se encontr√≥ _set_plan; se guardaron las rutinas, pero no se pudo programar en calendario.")
                except Exception as e:
                    st.error(f"Error al programar: {e}")

            with st.expander("Ver JSON (avanzado)", expanded=False):
                st.json(rutina_view)

    with st.expander("Exportar rutina (PDF)", expanded=False):
        from io import BytesIO
        try:
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
        except Exception as _e:
            st.error("Falta la dependencia 'reportlab'. Inst√°lala con: pip install reportlab"); st.stop()

        def _build_pdf(title: str, items: list, fecha: str | None = None) -> bytes:
            buf = BytesIO()
            doc = SimpleDocTemplate(buf, pagesize=A4, leftMargin=36, rightMargin=36, topMargin=36, bottomMargin=36)
            styles = getSampleStyleSheet(); story=[]
            story.append(Paragraph(title, styles["Title"]))
            if fecha: story.append(Paragraph(f"Fecha: {fecha}", styles["Normal"]))
            story.append(Spacer(1, 12))
            data = [["Ejercicio","Series","Reps","Peso (kg)"]]
            for it in items:
                data.append([str(it.get("exercise","")), str(it.get("sets","")), str(it.get("reps","")), str(it.get("weight",""))])
            table = Table(data, repeatRows=1)
            table.setStyle(TableStyle([("BACKGROUND",(0,0),(-1,0),colors.lightgrey),("GRID",(0,0),(-1,-1),0.5,colors.grey),("ALIGN",(1,1),(-1,-1),"CENTER"),("VALIGN",(0,0),(-1,-1),"MIDDLE"),("FONTSIZE",(0,0),(-1,-1),10),("BOTTOMPADDING",(0,0),(-1,0),6),("TOPPADDING",(0,0),(-1,0),6)]))
            story.append(table); doc.build(story); pdf=buf.getvalue(); buf.close(); return pdf

        mode = st.radio("¬øQu√© quieres exportar?", ["Rutina de hoy", "Elegir rutina"], horizontal=True)
        if mode == "Rutina de hoy":
            today = date.today(); today_iso = today.isoformat()
            rt_name = _get_plan(user).get(today_iso)
            if not rt_name: st.info("Hoy no hay rutina asignada.")
            else:
                r = next((rr for rr in list_routines(user) if rr["name"] == rt_name), None)
                if not r: st.warning("La rutina asignada ya no existe.")
                else:
                    pdf_bytes = _build_pdf(f"Rutina de hoy ‚Äî {rt_name}", r.get("items", []), fecha=today_iso)
                    st.download_button("Descargar PDF", data=pdf_bytes, file_name=f"rutina_{today_iso}_{rt_name}.pdf", mime="application/pdf", use_container_width=True)
        else:
            routines = list_routines(user)
            if not routines: st.info("No tienes rutinas creadas a√∫n.")
            else:
                names = [r["name"] for r in routines]
                sel = st.selectbox("Rutina a exportar", names, key="export_sel_routine")
                if sel:
                    r = next(rr for rr in routines if rr["name"] == sel)
                    pdf_bytes = _build_pdf(f"Rutina ‚Äî {sel}", r.get("items", []))
                    st.download_button("Descargar PDF", data=pdf_bytes, file_name=f"rutina_{sel}.pdf", mime="application/pdf", use_container_width=True)



elif page == "üë§ Perfil":
    require_auth()
    st.title("üë§ Mi perfil")
    user = st.session_state["user"]
    data = load_user(user)
    profile = data.get("profile", {})
    with st.form("perfil_form"):
        c1, c2 = st.columns(2)
        with c1:
            first_name = st.text_input("Nombre", value=profile.get("first_name",""))
            birthdate = st.text_input("Fecha de nacimiento (YYYY-MM-DD)", value=profile.get("birthdate",""))
        with c2:
            last_name = st.text_input("Apellidos", value=profile.get("last_name",""))
            gender = st.selectbox("G√©nero", ["", "Masculino", "Femenino", "No binario", "Prefiero no decir"], index=0 if profile.get("gender","") not in ["","Masculino","Femenino","No binario","Prefiero no decir"] else ["","Masculino","Femenino","No binario","Prefiero no decir"].index(profile.get("gender","")))
        notes = st.text_area("Notas", value=profile.get("notes",""))
        save_btn = st.form_submit_button("Guardar perfil")
    if save_btn:
        set_profile(user, {"first_name": first_name, "last_name": last_name, "birthdate": birthdate, "gender": gender, "notes": notes})
        st.success("Perfil actualizado.")

    st.subheader("Cambiar contrase√±a")
    with st.form("pass_form"):
        cur = st.text_input("Contrase√±a actual", type="password")
        p1  = st.text_input("Nueva contrase√±a", type="password")
        p2  = st.text_input("Repite nueva contrase√±a", type="password")
        sbt = st.form_submit_button("Actualizar contrase√±a")
    if sbt:
        if not authenticate(user, cur):
            st.error("La contrase√±a actual no es correcta.")
        elif not p1 or p1 != p2:
            st.error("Las nuevas contrase√±as no coinciden.")
        else:
            set_password(user, p1)
            st.success("Contrase√±a actualizada.")

    st.subheader("Emails")
    acc, rec = get_emails_for_user(user)
    with st.form("email_form"):
        new_acc = st.text_input("Email de cuenta", value=acc or "")
        new_rec = st.text_input("Email de recuperaci√≥n", value=rec or acc or "")
        sbt2 = st.form_submit_button("Guardar emails")
    if sbt2:
        if new_acc: set_account_email(user, new_acc)
        if new_rec: set_recovery_email(user, new_rec)
        st.success("Emails actualizados.")